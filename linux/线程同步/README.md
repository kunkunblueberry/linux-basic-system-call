### 一、读写锁核心知识点
1. **基本特性**：
   - **读共享**：多个线程可同时获取**读锁**，并发读取共享资源，互不阻塞。
   - **写独占**：同一时间仅一个线程能获取**写锁**；且写锁与任意读锁互斥（读锁存在时写锁无法获取，写锁存在时读锁也无法获取）。
2. **初始化方式**：
   - **动态初始化**：通过 `pthread_rwlock_init` 函数初始化，需显式调用 `pthread_rwlock_destroy` 销毁（释放资源）。
   - **静态初始化**：使用宏 `PTHREAD_RWLOCK_INITIALIZER`（如 `pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;`），适用于全局/静态变量，无需手动销毁。
3. **核心函数**：
   - 加读锁：`pthread_rwlock_rdlock`（阻塞式，有写锁则等待）、`pthread_rwlock_tryrdlock`（非阻塞式，失败直接返回错误）。
   - 加写锁：`pthread_rwlock_wrlock`（阻塞式，有读/写锁则等待）、`pthread_rwlock_trywrlock`（非阻塞式，失败直接返回错误）。
   - 解锁（通用）：`pthread_rwlock_unlock`。
   - 初始化/销毁：`pthread_rwlock_init`、`pthread_rwlock_destroy`。
4. **属性控制**：
   - 可通过 `pthread_rwlockattr_t` 配置属性（如优先级），解决“读优先导致写操作长期等待（写饥饿）”问题（示例中用 `PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP` 让写操作优先）。


### 二、代码编写易错点
1. **锁作用域错误**：
   - 写操作时，未用写锁包裹**完整的“读-改-写”逻辑**（如第一段代码写线程最初没加锁，导致数据竞争）。
   - 读操作时，未加读锁就访问共享数据，可能读到“中间态”脏数据。
2. **锁销毁时机错误**：
   - 调用 `pthread_rwlock_destroy` 时，仍有线程持有读/写锁，会导致未定义行为。
3. **静态/动态初始化混淆**：
   - 动态初始化的锁（`pthread_rwlock_init`），忘记调用 `pthread_rwlock_destroy`，导致资源泄漏。
4. **优先级导致的饥饿**：
   - 默认“读优先”下，若读操作频繁，写操作可能因长期等待读锁释放而“饥饿”，需手动配置属性调整优先级。
5. **线程同步遗漏**：
   - 忘记用 `pthread_join` 等待子线程结束，主线程提前退出导致子线程逻辑未执行完。


### 三、代码编写关键点
1. **锁的作用域包裹**：
   - 写操作：必须用 `pthread_rwlock_wrlock` 和 `pthread_rwlock_unlock` 包裹**修改共享数据的完整逻辑**（如第二段代码中写线程的“读-改-写”过程）。
   - 读操作：用 `pthread_rwlock_rdlock` 和 `pthread_rwlock_unlock` 包裹**读取共享数据的逻辑**，保证读取时数据不被写操作修改。
2. **初始化与销毁的配对**：
   - 动态初始化的锁（`pthread_rwlock_init`），需在所有线程不再使用锁后，调用 `pthread_rwlock_destroy` 释放资源。
3. **线程的创建与等待**：
   - 用 `pthread_create` 创建线程后，通过 `pthread_join` 等待线程执行完毕，确保锁保护的逻辑完整执行。
4. **属性配置（解决写饥饿）**：
   - 写操作需优先时，通过 `pthread_rwlockattr_t` 配置属性（如 `pthread_rwlock_setkind_np` 设置为写优先），避免写操作因读操作过多而长期等待。


### 四、掌握读写锁的核心要点
1. **理解“读共享、写独占”本质**：
   读锁是“共享锁”（允许多读），写锁是“独占锁”（读写/写写互斥），这是读写锁提升读操作并发效率的核心。
2. **明确函数适用场景**：
   阻塞式加锁（`rdlock`/`wrlock`）适合能容忍等待的场景；非阻塞式加锁（`tryrdlock`/`trywrlock`）适合需立即判断锁状态的场景（如防死锁）。
3. **重视锁的生命周期管理**：
   初始化、加锁、解锁、销毁的流程必须完整，避免资源泄漏或未定义行为。
4. **灵活调整优先级**：
   根据业务场景（读多写少/写多读少），选择“读优先”或“写优先”属性，平衡并发效率与写操作响应性。
5. **结合线程同步保证逻辑完整性**：
   线程创建后需用 `pthread_join` 同步，确保共享资源操作在主线程结束前完成。